# -*- coding: utf-8 -*-
"""modeloimage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hvOZqLsMM4GhLqfaZFttYCFesPMlxgw7
"""

pip install imageio matplotlib

import imageio
import numpy as np
import matplotlib.pyplot as plt



def convert_to_grayscale_no_libs(image_path):

        # Read the image using imageio
        img = imageio.imread(image_path)

        # Get image dimensions
        height, width, channels = img.shape

        # Create a new array for the grayscale image
        grayscale_img = np.zeros((height, width), dtype=np.uint8)

        # Iterate through each pixel and calculate grayscale value
        for i in range(height):
            for j in range(width):
                # Get RGB values for the current pixel
                r, g, b = img[i, j]

                # Calculate luminance (grayscale value)
                gray_value = int(0.299 * r + 0.587 * g + 0.114 * b)

                # Assign grayscale value to the new image array
                grayscale_img[i, j] = gray_value

        return grayscale_img

def convert_to_binary(grayscale_image, threshold=128):

    binary_image = np.where(grayscale_image > threshold, 255, 0)
    return binary_image.astype(np.uint8)

input_image_path = "/content/drive/MyDrive/Estudos/imagens/comida.jpg"

 grayscale_image = convert_to_grayscale_no_libs(input_image_path)


 # Example usage

# Example usage

if grayscale_image is not None:
    original_image = imageio.imread(input_image_path)
    binary_image = convert_to_binary(grayscale_image)

    plt.figure(figsize=(15, 5))

    plt.subplot(1, 3, 1)
    plt.imshow(original_image)
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 3, 2)
    plt.imshow(grayscale_image, cmap="gray")
    plt.title("Grayscale Image")
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.imshow(binary_image, cmap="gray")
    plt.title("Binary Image")
    plt.axis("off")

    plt.show()

input_image_path = "/content/drive/MyDrive/PaisagensDia/imagensDia/nuvens.jpg"


grayscale_image = convert_to_grayscale_no_libs(input_image_path)


if grayscale_image is not None:

    original_image = imageio.imread(input_image_path)

    # Display the original image
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.imshow(original_image)
    plt.title("Imagem Original")
    plt.axis("off")


    plt.subplot(1, 2, 2)
    plt.imshow(grayscale_image, cmap="gray")
    plt.title("Imagem em Cinza")
    plt.axis("off")

    plt.show()

os.chdir('/content/drive/My Drive/Estudos/imagens/paisagemDia')

plt.imshow(img)

from PIL import Image

def convert_to_grayscale(image_path, output_path):
    """
    Converts an image to grayscale and saves it to a new file.

    Args:
        image_path: The path to the input image file.
        output_path: The path to save the converted grayscale image.
    """
    try:
        # Open the image using Pillow library
        img = Image.open(image_path)

        # Convert the image to grayscale ("L" mode)
        grayscale_img = img.convert("L")

        # Save the grayscale image
        grayscale_img.save(output_path)
        print(f"Image converted to grayscale and saved to: {output_path}")

    except FileNotFoundError:
        print(f"Error: Image file not found at {image_path}")
    except Exception as e:
        print(f"An error occurred: {e}")

# Example usage
input_image_path = '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem2.jpg'  # Replace with your image path
output_image_path = "grayscale_image.jpg"  # Replace with desired output path

convert_to_grayscale(input_image_path, output_image_path)

import matplotlib.pyplot as plt
from PIL import Image  # If you're using Pillow to load the image


# Load the image (using Pillow)
image = Image.open("grayscale_image.jpg")  # Replace with your image path


# Display the image using matplotlib
plt.imshow(image)
plt.axis('off')  # Optional: Hide axis ticks and labels
plt.show()

import numpy as np
import torch
import torch.nn.functional as F
import torchvision
import matplotlib.pyplot as plt
from time import time
from torchvision import datasets, transforms
from torch import nn, optim

from tensorflow.keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(
     rescale=1./255,
     shear_range=0.2,
     zoom_range=0.2,
     horizontal_flip=True
 )

test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
         os.path.join(pasta_dataset, "paisagemDia"),
         target_size=(150, 150),
         batch_size=32,
         class_mode='binary'
     )

print(pasta_dataset)

train_generator = train_datagen.flow_from_directory(
         os.path.join(pasta_dataset, 'paisagemDia'),
         target_size=(150, 150),
         batch_size=32,
         class_mode='binary'
     )

     validation_generator = test_datagen.flow_from_directory(
         os.path.join(pasta_dataset, 'paisagemNoite'),
         target_size=(150, 150),
         batch_size=32,
         class_mode='binary'
     )

import os

import tensorflow as tf
import os

pasta_dataset = '/content/drive/MyDrive/Estudos/imagens'

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from google.colab import drive

drive.mount('/content/drive')

import os
print(os.listdir(pasta_dataset))

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
import os

!pip install --upgrade tensorflow

pasta_principal = '/content/drive/MyDrive/Teste'

classes = ['imagedia', 'noiteimage']

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
import os

train_dir = '/content/drive/MyDrive/PaisagensDia'
test_dir = '/content/drive/MyDrive/PaisagensNoite'

train_datagen = tf.keras.preprocessing.image.ImageDataGenerator(
    rescale=1./255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True
)

test_datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='binary'
)

test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(150, 150),
    batch_size=32,
    class_mode='binary'
)

model = keras.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

from tensorflow import keras
from tensorflow.keras import layers

# Define the input shape
input_shape = (150, 150, 3)  # Update with your desired input shape

# Create an Input object
inputs = keras.Input(shape=input_shape)

# Build the rest of your model, starting with the Input object
model = keras.Sequential([
    inputs,
    layers.Conv2D(32, (3, 3), activation='relu'),  # No input_shape here
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

history = model.fit(
    train_generator,
    steps_per_epoch=2000 // 32,  # Número de passos por época
    epochs=10,  # Número de épocas
    validation_data=test_generator,
    validation_steps=800 // 32  # Número de passos de validação
)

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

img_path = '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem2.jpg'
img = load_img(img_path, target_size=(150, 150)) # Ajuste o target_size se necessário
img_array = img_to_array(img)
img_array = img_array / 255.0  # Normalização
img_array = np.expand_dims(img_array, axis=0)  # Adicionar dimensão do lote

image_paths = [
   '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem2.jpg',
   '/content/drive/MyDrive/PaisagensDia/imagensDia/nuvens.jpg',
   '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',
   '/content/drive/MyDrive/PaisagensNoite/imagensNoite/finaldatarde.jpg',

]

img = load_img(img_path, target_size=(150, 150)) # Ajuste o target_size se necessário
img_array = img_to_array(img)
img_array = img_array / 255.0  # Normalização
img_array = np.expand_dims(img_array, axis=0)

prediction = model.predict(img_array)

class_names = ['imagensDia', 'imagensNoite']  # Substitua pelos nomes das suas classes

predicted_class_index = int(prediction[0][0] < 0.5)  # Se a probabilidade for maior que 0.5, pertence à classe 1
predicted_class = class_names[predicted_class_index]

print(f"A imagem é classificada como: {predicted_class}")

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import matplotlib.pyplot as plt

img_path = '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem2.jpg'
img = load_img(img_path, target_size=(150, 150))  # Load the image

plt.imshow(img)
plt.title(f"Predicted Class: {predicted_class}")  # Set the title with prediction
plt.show()



from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import matplotlib.pyplot as plt

image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',

]

class_names = ['imagensDia', 'imagensNoite']

# Create a figure and axes for subplots
fig, axes = plt.subplots(1, 2, figsize=(10, 5))  # 1 row, 2 columns


# Loop through images and display with predictions
for i, img_path in enumerate(image_paths):
    img = load_img(img_path, target_size=(150, 150))
    img_array = img_to_array(img)
    img_array = img_array / 100.0
    img_array = np.expand_dims(img_array, axis=0)

    prediction = model.predict(img_array)

    # Limite para cada classe
    threshold = 0.5


    predicted_classes = []

    if prediction[0][0] > threshold:  # prediction[0][0] has the prediction for the single class
        predicted_classes.append(class_names[0]) # Isso é "imagensDia"

    if prediction[0][0] <= threshold :
       predicted_classes.append(class_names[1])

    # Cria um título
    title = "Predição: " + ", ".join(predicted_classes)

    # Display image and title in the corresponding subplot
    axes[i].imshow(img)
    axes[i].set_title(title)
    axes[i].axis('off')  # Hide axis ticks

plt.tight_layout()  # Adjust layout for better spacing
plt.show()

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import matplotlib.pyplot as plt

image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem2.jpg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem9.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/finaldatarde.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem19.jpeg',
]

class_names = ['imagensDia', 'imagensNoite']

# Ajustar o número de subplots para corresponder ao número de imagens
num_images = len(image_paths)
num_cols = 2  # Número de colunas na grade de subplots
num_rows = (num_images + num_cols - 1) // num_cols  # Calcula o número de linhas necessárias

# Criar uma figura e eixos para subplots com as dimensões corretas
fig, axes = plt.subplots(num_rows, num_cols, figsize=(10, 5 * num_rows))

# Achatando o array de eixos, se necessário (para indexação mais fácil)
axes = axes.flatten()

# Loop pelas imagens e exibição com previsões
for i, img_path in enumerate(image_paths):
    img = load_img(img_path, target_size=(150, 150))
    img_array = img_to_array(img)
    img_array = img_array / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    prediction = model.predict(img_array)

    # Limite para cada classe
   # threshold = 0.5

    #predicted_classes = []

    # Verifica se a predição para a classe 'imagensDia' está acima do limite
    #if prediction[0][0] > threshold:  # prediction[0][0] has the prediction for the single class
        #predicted_classes.append(class_names[0]) # Isso é "imagensDia"

    #if not prediction[0][1] <= threshold:
       #predicted_classes.append(class_names[1])

       #class_names = ['imagensDia', 'imagensNoite']  # Substitua pelos nomes das suas classes

#predicted_class_index = int(prediction[0][0] > 0.5)  # Se a probabilidade for maior que 0.5, pertence à classe 1
#predicted_class = class_names[predicted_class_index]
    # Define o limite para a classificação
    mean_intensity = np.mean(img_array)
    std_intensity = np.std(img_array)

  # Definir o limite como a média mais um múltiplo do desvio padrão
    threshold = mean_intensity + (std_intensity * multiplier)

  # Classificar a imagem
  if mean_intensity > threshold:
    predicted_class = "imagensDia"
  else:
    predicted_class = "imagensNoite"

  return predicted_class

  predicted_class = classify_image(image_path, multiplier=0.5)

       print(f"A imagem é classificada como: {predicted_class}")



    # Cria um título
    title = "Predição: " + ", ".join(predicted_classes)

    # Exibe a imagem e o título no subplot correspondente
    axes[i].imshow(img)
    axes[i].set_title(title)
    axes[i].axis('off')  # Oculta os ticks do eixo

plt.tight_layout()  # Ajusta o layout para melhor espaçamento
plt.show()

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import matplotlib.pyplot as plt

def classify_image(image_path, multiplier=0.5):
    # ... (your existing classify_image function code) ...
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img)
    img_array = img_array / 255.0
    img_array = np.expand_dims(img_array, axis=0)

# Separate image paths and class names
image_paths_day = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem2.jpg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem9.jpeg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem9.jpeg',
]

class_names_day = ['imagensDia']  # Class name for day images

image_paths_night = [
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/finaldatarde.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem19.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',

]
class_names_night = ['imagensNoite']  # Class name for night images


# Process and display images for each class separately
def process_and_display(image_paths, class_names):
    num_images = len(image_paths)
    num_cols = 3
    num_rows = (num_images + num_cols - 1) // num_cols

    fig, axes = plt.subplots(num_rows, num_cols, figsize=(10, 5 * num_rows))
    axes = axes.flatten()

    for i, img_path in enumerate(image_paths):
        img = load_img(img_path, target_size=(150, 150))
        predicted_class = classify_image(img_path)
        axes[i].imshow(img)
        axes[i].set_title(f"Classe: {class_names[0]}")  # Use the corresponding class name
        axes[i].axis('off')

    fig.suptitle(f"Imagens da classe: {class_names[0]}", fontsize=16)
    plt.tight_layout()
    plt.show()


# Call the function for each class
process_and_display(image_paths_day, class_names_day)
process_and_display(image_paths_night, class_names_night)

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import matplotlib.pyplot as plt

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
import os

from tensorflow.keras.preprocessing.image import ImageDataGenerator # Import the ImageDataGenerator class

train_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
      '/content/drive', # Caminho para a pasta principal
      target_size=(150, 150), # Tamanho das imagens
      batch_size=2, # Tamanho do lote (2 para as duas imagens)
      class_mode='binary' # Modo de classificação binária
  )

import tensorflow as tf

import tensorflow as tf

model = tf.keras.Sequential([
      tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)),
      tf.keras.layers.MaxPooling2D((2, 2)),
      tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
      tf.keras.layers.MaxPooling2D((2, 2)),
      tf.keras.layers.Flatten(),
      tf.keras.layers.Dense(1, activation='sigmoid')
  ])

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

model.fit(train_generator, epochs=10) # Ajuste o número de épocas

from tensorflow.keras.preprocessing.image import load_img, img_to_array
img1 = load_img('/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg', target_size=(150, 150))
img_array1 = img_to_array(img1) / 255.0
img_array1 = img_array1.reshape((1, 150, 150, 3))
  # Repita para img2

from tensorflow.keras.preprocessing.image import load_img, img_to_array
img2 = load_img('/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg', target_size=(150, 150))
img_array2 = img_to_array(img2) / 255.0
img_array2 = img_array1.reshape((1, 150, 150, 3))
  # Repita para img2

prediction1 = model.predict(img_array1)
  # Repita para img2

prediction2 = model.predict(img_array2)
  # Repita para img2

class_names = ['PaisagensDia', 'PaisagensNoite']
  predicted_class_index1 = int(prediction1[0][0] < 0.5)
  predicted_class_name1 = class_names[predicted_class_index1]
  print(f"Imagem 1: {predicted_class_name1}")

class_names = ['PaisagensDia', 'PaisagensNoite']
  predicted_class_index2 = int(prediction2[0][0] > 0.5)
  predicted_class_name2 = class_names[predicted_class_index2]
  print(f"Imagem 2: {predicted_class_name2}")

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',
]

img1 = load_img(image_paths[0], target_size=(150, 150))
img_array1 = img_to_array(img1) / 255.0
img_array1 = img_array1.reshape((1, 150, 150, 3))

img2 = load_img(image_paths[1], target_size=(150, 150))
img_array2 = img_to_array(img2) / 255.0
img_array2 = img_array2.reshape((1, 150, 150, 3))

predictions = model.predict([img_array1, img_array2])
# Assuming binary classification (0 or 1)
predicted_classes = [int(p[0] > 0.5) for p in predictions]
predictions = [model.predict(img_array) for img_array in img_arrays]

class_names = ['PaisagensDia', 'PaisagensNoite']

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

def classify_image(image_path, model, class_names):
    """Classifies an image and returns the predicted class name."""
    img = load_img(image_path, target_size=(150, 150))  # Adjust target_size if needed
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] > 0.5)  # Or use np.argmax
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# Caminhos das imagens (diferentes para cada classe)
image_paths = {
    'Paisagem Diurna': '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem10.jpeg',
    'Final da Tarde':'/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',
}

# Dicionário de nomes de classes (como definido anteriormente)
class_names = {
    0: 'Paisagem Diurna',
    1: 'Final da Tarde',
}

# Carregar e pré-processar as imagens
imgs = []
img_arrays = []
for class_name, img_path in image_paths.items():  # Iterar pelo dicionário
    img = load_img(img_path, target_size=(150, 150))
    imgs.append(img)
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))
    img_arrays.append(img_array)

# Fazer as previsões e exibir com nomes de classes distintos
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

for i, (class_name, img_path) in enumerate(image_paths.items()):  # Iterar novamente
    axes[i].imshow(imgs[i])  # Exibir a imagem original

    # Fazer a previsão (opcional, se quiser mostrar a previsão real também)
    prediction = model.predict(img_arrays[i])
    predicted_class_index = int(prediction[0][0] > 0.5)
    predicted_class_name = class_names[predicted_class_index]

    # Definir o título com o nome da classe desejado
    axes[i].set_title(f"Prediction: {class_name}")  # Usar o nome da classe do dicionário
    axes[i].axis('off')

plt.show()

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# ... (your existing code for model and class_names) ...


# Caminhos das imagens (diferentes para cada classe)


def predict_day_image(image_path, model):
    """Predicts if an image is a day scene ('Cena Diurna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] < 0.5)  # Threshold for 'Cena Diurna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name


def predict_night_image(image_path, model):
    """Predicts if an image is a night scene ('Cena Noturna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] > 0.5)  # Threshold for 'Cena Noturna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name

# Example usage:
image_path_day = '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem5.jpeg'
image_path_night = '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg'

day_prediction = predict_day_image(image_path_day, model)
night_prediction = predict_night_image(image_path_night, model)

print(f"Day image prediction: {day_prediction}")
print(f"Night image prediction: {night_prediction}")

from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# ... (your existing code for model and class_names) ...
class_names = {
    0: 'Cena Diurna',
    1: 'Cena Noturna',
}

# ... (predict_day_image and predict_night_image functions from previous response) ...

def predict_day_image(image_path, model):
    """Predicts if an image is a day scene ('Cena Diurna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] < 0.5)  # Threshold for 'Cena Diurna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name


def predict_night_image(image_path, model):
    """Predicts if an image is a night scene ('Cena Noturna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] > 0.5)  # Threshold for 'Cena Noturna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name

# Caminhos das imagens
image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem5.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem16.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',


]

# Classificar as quatro imagens
for i, img_path in enumerate(image_paths):
    # Decide which function to use based on expected image type (day or night)
    if 'PaisagensDia' in img_path:
        predicted_class = predict_day_image(img_path, model)
    else:  # Assuming 'PaisagensNoite' in img_path
        predicted_class = predict_night_image(img_path, model)

    print(f"Imagem {i + 1}: {img_path} - Prediction: {predicted_class}")

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# Assuming you have your model loaded as 'model' and class_names defined

class_names = {
    0: 'Cena Diurna',
    1: 'Cena Noturna',
}

# ... (predict_day_image and predict_night_image functions from previous response) ...

def predict_day_image(image_path, model):
    """Predicts if an image is a day scene ('Cena Diurna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] < 0.5)  # Threshold for 'Cena Diurna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name


def predict_night_image(image_path, model):
    """Predicts if an image is a night scene ('Cena Noturna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] > 0.5)  # Threshold for 'Cena Noturna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name

    return predicted_class_name



# Image paths
image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem5.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',
    # ... add more image paths as needed
]

for i, img_path in enumerate(image_paths):
    # Decide which function to use based on expected image type (day or night)
    if 'PaisagensDia' in img_path:
        predicted_class = predict_day_image(img_path, model)
    else:  # Assuming 'PaisagensNoite' in img_path
        predicted_class = predict_night_image(img_path, model)

    print(f"Imagem {i + 1}: {img_path} - Prediction: {predicted_class}")

    img = load_img(img_path, target_size=(150, 150))
    plt.imshow(img)
    plt.title(f"Prediction: {predicted_class}")
    plt.axis('off')
    plt.show()

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# Assuming you have your model loaded as 'model' and class_names defined

class_names = {
    0: 'Cena Diurna',
    1: 'Cena Noturna',
}

def predict_day_image(image_path, model):
    """Predicts if an image is a day scene ('Cena Diurna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] < 0.5)  # Threshold for 'Cena Diurna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name
    predicted_class_name = "Paisagem de Dia"

    return predicted_class_name


def predict_night_image(image_path, model):
    """Predicts if an image is a night scene ('Cena Noturna')."""
    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] > 0.5)  # Threshold for 'Cena Noturna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name
    predicted_class_name = "Final da Tarde"

    return predicted_class_name



    # Modify this part to display "ImagemDia" when prediction is 0


# ... (rest of your code for loading and displaying images) ...
image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem5.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',
    # ... add more image paths as needed
]

# Inside the display loop:


for i, img_path in enumerate(image_paths):
    # Decide which function to use based on expected image type (day or night)
    if 'PaisagensDia' in img_path:
        predicted_class = predict_day_image(img_path, model)
    else:  # Assuming 'PaisagensNoite' in img_path
        predicted_class = predict_night_image(img_path, model)



    img = load_img(img_path, target_size=(150, 150))
    plt.imshow(img)
    plt.title(f"Prediction: {predicted_class}")

    plt.axis('off')
    plt.show()



# ... (rest of your code) ...

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# ... (your existing code for model, class_names, predict_day_image, predict_night_image) ...

class_names = {
    0: 'Cena Diurna',
    1: 'Cena Noturna',
}

def predict_day_image(image_path, model):
    """Predicts if an image is a day scene ('Cena Diurna')."""

    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] < 0.5)  # Threshold for 'Cena Diurna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name
    predicted_class_name = "Paisagem de Dia"

    return predicted_class_name


def predict_night_image(image_path, model):
    """Predicts if an image is a night scene ('Cena Noturna')."""

    img = load_img(image_path, target_size=(150, 150))
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))

    prediction = model.predict(img_array)
    predicted_class_index = int(prediction[0][0] > 0.5)  # Threshold for 'Cena Noturna'

    # Assuming class_names = {0: 'Cena Diurna', 1: 'Cena Noturna'}
    predicted_class_name = list(class_names.keys())[predicted_class_index]  # Get class name
    predicted_class_name = "Final da Tarde"

    return predicted_class_name



# Image paths
image_paths = [
    '/content/drive/MyDrive/PaisagensDia/imagensDia/paisagem5.jpeg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/paisagem30.jpeg',
    '/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg',
    '/content/drive/MyDrive/PaisagensNoite/imagensNoite/foto7.jpeg',
    # ... add more image paths as needed
]

# Load and predict for each image
imgs = []
predictions = []
for img_path in image_paths:
    img = load_img(img_path, target_size=(150, 150))
    imgs.append(img)

    # Decide which function to use based on expected image type (day or night)
    if 'PaisagensDia' in img_path:
        predicted_class = predict_day_image(img_path, model)
    else:  # Assuming 'PaisagensNoite' in img_path
        predicted_class = predict_night_image(img_path, model)

    predictions.append(predicted_class)

# Display images with predictions
fig, axes = plt.subplots(len(image_paths) // 2, 2, figsize=(10, 5 * (len(image_paths) // 2)))  # Adjust grid as needed
axes = axes.flatten()  # In case of multiple rows/cols

for i, img in enumerate(imgs):
    axes[i].imshow(img)
    axes[i].set_title(f"Prediction: {predictions[i]}")
    axes[i].axis('off')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
from tensorflow import keras

import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from sklearn.metrics import confusion_matrix, accuracy_score, recall_score, precision_score, f1_score



# 1. Definir caminhos e classes
pasta_imagens = '/content/drive/MyDrive/Estudos/imagens'  # Substitua pelo caminho da sua pasta
classes = {'paisagemDia': 0, 'paisagemNoite': 1}  # Update class names to match your folder structure

# 2. Carregar rótulos verdadeiros (y_true) and image paths
y_true = []
image_paths = []  # Store image paths for prediction
for classe, rotulo in classes.items():
    pasta_classe = os.path.join(pasta_imagens, classe)
    for nome_arquivo in os.listdir(pasta_classe):
        if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):  # Consider common image extensions
            y_true.append(rotulo)
            image_paths.append(os.path.join(pasta_classe, nome_arquivo))
y_true = np.array(y_true)

# 3. Carregar e pré-processar imagens, obter previsões (y_pred)
y_pred = []
for img_path in image_paths:
    imagem = load_img(img_path, target_size=(150, 150))
    imagem_array = img_to_array(imagem) / 255.0
    imagem_array = imagem_array.reshape((1, 150, 150, 3))
    prediction = model.predict(imagem_array)
    predicted_class = int(prediction[0][0] > 0.5)
    y_pred.append(predicted_class)
y_pred = np.array(y_pred)

# 4. Calcular a matriz de confusão ANTES de calcular a especificidade
cm = confusion_matrix(y_true, y_pred) # Moved this line up


accuracy = accuracy_score(y_true, y_pred)
sensitivity = recall_score(y_true, y_pred)
specificity = cm[0, 0] / (cm[0, 0] + cm[0, 1]) # Now cm is defined
precision = precision_score(y_true, y_pred)
f1 = f1_score(y_true, y_pred)


# Exibir as métricas
print(f"Acurácia: {accuracy}")
print(f"Sensibilidade (Recall): {sensitivity}")
print(f"Especificidade: {specificity}")
print(f"Precisão: {precision}")
print(f"F-score: {f1}")


plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=list(classes.keys()),
            yticklabels=list(classes.keys()))
plt.xlabel("Rótulo Predito")
plt.ylabel("Rótulo Verdadeiro")
plt.title("Matriz de Confusão")
plt.show()


model.save('minha_imagem_classifica.keras')
print("Model saved to 'minha_imagem_classifica.keras'")

import numpy as np



TP = np.sum((y_true == 1) & (y_pred == 1))  # Conta onde ambos, y_true e y_pred, são 1
FN = np.sum((y_true == 1) & (y_pred == 0))  # Conta onde y_true é 1 e y_pred é 0
sensibilidade = TP / (TP + FN)
print(f"Sensibilidade (Recall): {sensibilidade}")

corretos = y_true == y_pred
num_corretos = np.sum(corretos)
acuracia = num_corretos / len(y_true)
print(f"Acurácia: {acuracia}")

import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from sklearn.metrics import confusion_matrix, accuracy_score, recall_score, precision_score, f1_score



# 1. Definir caminhos e classes
pasta_imagens = '/content/drive/MyDrive/Estudos/imagens'  # Substitua pelo caminho da sua pasta
classes = {'paisagemDia': 0, 'paisagemNoite': 1}  # Update class names to match your folder structure

# 2. Carregar rótulos verdadeiros (y_true) and image paths
y_true = []
image_paths = []  # Store image paths for prediction
for classe, rotulo in classes.items():
    pasta_classe = os.path.join(pasta_imagens, classe)
    for nome_arquivo in os.listdir(pasta_classe):
        if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):  # Consider common image extensions
            y_true.append(rotulo)
            image_paths.append(os.path.join(pasta_classe, nome_arquivo))
y_true = np.array(y_true)

# 3. Carregar e pré-processar imagens, obter previsões (y_pred)
y_pred = []
for img_path in image_paths:
    imagem = load_img(img_path, target_size=(150, 150))
    imagem_array = img_to_array(imagem) / 255.0
    imagem_array = imagem_array.reshape((1, 150, 150, 3))
    prediction = model.predict(imagem_array)
    predicted_class = int(prediction[0][0] > 0.5)
    y_pred.append(predicted_class)
y_pred = np.array(y_pred)

# 4. Calcular a matriz de confusão ANTES de calcular a especificidade
cm = confusion_matrix(y_true, y_pred) # Moved this line up



corretos = y_true == y_pred
num_corretos = np.sum(corretos)
acuracia = num_corretos / len(y_true)
print(f"Acurácia: {acuracia}")

TP = np.sum((y_true == 1) & (y_pred == 1))
FN = np.sum((y_true == 1) & (y_pred == 0))  # Conta onde y_true é 1 e y_pred é 0
sensibilidade = TP / (TP + FN)
print(f"Sensibilidade (Recall): {sensibilidade}")


TP = np.sum((y_true == 1) & (y_pred == 1))
FP = np.sum((y_true == 0) & (y_pred == 1))
precisao = TP / (TP + FP)
print(f"Precisão: {precisao}")


def calcular_f1_score(y_true, y_pred):
    """Calcula o F1-score."""
    TP = np.sum((y_true == 1) & (y_pred == 1))
    FP = np.sum((y_true == 0) & (y_pred == 1))
    FN = np.sum((y_true == 1) & (y_pred == 0))

    precisao = TP / (TP + FP) if (TP + FP) != 0 else 0
    sensibilidade = TP / (TP + FN) if (TP + FN) != 0 else 0

    f1_score = 2 * (precisao * sensibilidade) / (precisao + sensibilidade) if (precisao + sensibilidade) != 0 else 0
    return f1_score

f1 = calcular_f1_score(y_true, y_pred)
print(f"F1-score: {f1}")

plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=list(classes.keys()),
            yticklabels=list(classes.keys()))
plt.xlabel("Rótulo Predito")
plt.ylabel("Rótulo Verdadeiro")
plt.title("Matriz de Confusão")
plt.show()


model.save('minha_imagem_classifica.keras')
print("Model saved to 'minha_imagem_classifica.keras'")

import numpy as np

def calcular_f1_score(y_true, y_pred):
    """Calcula o F1-score."""
    TP = np.sum((y_true == 1) & (y_pred == 1))
    FP = np.sum((y_true == 0) & (y_pred == 1))
    FN = np.sum((y_true == 1) & (y_pred == 0))

    precisao = TP / (TP + FP) if (TP + FP) != 0 else 0
    sensibilidade = TP / (TP + FN) if (TP + FN) != 0 else 0

    f1_score = 2 * (precisao * sensibilidade) / (precisao + sensibilidade) if (precisao + sensibilidade) != 0 else 0
    return f1_score

# Example usage:
y_true = np.array([0, 1, 0, 1, 0, 1])
y_pred = np.array([0, 0, 0, 1, 1, 1])

f1 = calcular_f1_score(y_true, y_pred)
print(f"F1-score: {f1}")

from tensorflow import keras
modelo = keras.models.load_model('minha_imagem_classifica.keras')

corretos = y_true == y_pred
num_corretos = np.sum(corretos)
acuracia = num_corretos / len(y_true)
print(f"Acurácia: {acuracia}")

def calcular_f1_score(y_true, y_pred):
         TP = np.sum((y_true == 1) & (y_pred == 1))
         FP = np.sum((y_true == 0) & (y_pred == 1))
         FN = np.sum((y_true == 1) & (y_pred == 0))

         precisao = TP / (TP + FP) if (TP + FP) != 0 else 0
         sensibilidade = TP / (TP + FN) if (TP + FN) != 0 else 0

         f1_score = 2 * (precisao * sensibilidade) / (precisao + sensibilidade) if (precisao + sensibilidade) != 0 else 0
         return f1_score

f1 = calcular_f1_score(y_true, y_pred)
print(f"F1-score: {f1}")

import numpy as np

def calcular_f1_score(y_true, y_pred):
    """Calcula o F1-score."""
    TP = np.sum((y_true == 1) & (y_pred == 1))
    FP = np.sum((y_true == 0) & (y_pred == 1))
    FN = np.sum((y_true == 1) & (y_pred == 0))

    precisao = TP / (TP + FP) if (TP + FP) != 0 else 0
    sensibilidade = TP / (TP + FN) if (TP + FN) != 0 else 0

    f1_score = 2 * (precisao * sensibilidade) / (precisao + sensibilidade) if (precisao + sensibilidade) != 0 else 0
    return f1_score

# Example usage:
y_true = np.array([0, 1, 0, 1, 0, 1])
y_pred = np.array([0, 0, 0, 1, 1, 1])

f1 = calcular_f1_score(y_true, y_pred)
print(f"F1-score: {f1}")

import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from sklearn.metrics import confusion_matrix, accuracy_score, recall_score, precision_score, f1_score


# 1. Definir caminhos e classes
pasta_imagens = '/content/drive/MyDrive/Estudos/imagens'  # Substitua pelo caminho da sua pasta
classes = {'paisagemDia': 0, 'paisagemNoite': 1}  # Update class names to match your folder structure

# 2. Carregar rótulos verdadeiros (y_true) and image paths
y_true = []
image_paths = []  # Store image paths for prediction
for classe, rotulo in classes.items():
    pasta_classe = os.path.join(pasta_imagens, classe)
    for nome_arquivo in os.listdir(pasta_classe):
        if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):  # Consider common image extensions
            y_true.append(rotulo)
            image_paths.append(os.path.join(pasta_classe, nome_arquivo))
y_true = np.array(y_true)

# 3. Carregar e pré-processar imagens, obter previsões (y_pred)
y_pred = []
for img_path in image_paths:
    imagem = load_img(img_path, target_size=(150, 150))
    imagem_array = img_to_array(imagem) / 255.0
    imagem_array = imagem_array.reshape((1, 150, 150, 3))
    prediction = model.predict(imagem_array)
    predicted_class = int(prediction[0][0] > 0.5)
    y_pred.append(predicted_class)
y_pred = np.array(y_pred)

# 4. Calcular a matriz de confusão ANTES de calcular a especificidade
cm = confusion_matrix(y_true, y_pred) # Moved this line up


y_true = np.array([0, 1, 0, 1, 0, 1])
y_pred = np.array([0, 0, 0, 1, 1, 1])



print(f"Sensibilidade (Recall): {sensibilidade}")



def calcular_precisao(y_true, y_pred):

    TP = np.sum((y_true == 1) & (y_pred == 1))  # Verdadeiros Positivos
    FP = np.sum((y_true == 0) & (y_pred == 1))  # Falsos Positivos

    precisao = TP / (TP + FP) if (TP + FP) != 0 else 0  # Evita divisão por zero
    return precisao

precisao = calcular_precisao(y_true, y_pred)
print(f"Precisão: {precisao}")


def calcular_f1_score(y_true, y_pred):
    """Calcula o F1-score."""
    TP = np.sum((y_true == 1) & (y_pred == 1))
    FP = np.sum((y_true == 0) & (y_pred == 1))
    FN = np.sum((y_true == 1) & (y_pred == 0))

    precisao = TP / (TP + FP) if (TP + FP) != 0 else 0
    sensibilidade = TP / (TP + FN) if (TP + FN) != 0 else 0

    f1_score = 2 * (precisao * sensibilidade) / (precisao + sensibilidade) if (precisao + sensibilidade) != 0 else 0
    return f1_score


f1 = calcular_f1_score(y_true, y_pred)
print(f"F1-score: {f1}")



plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=list(classes.keys()),
            yticklabels=list(classes.keys()))
plt.xlabel("Rótulo Predito")
plt.ylabel("Rótulo Verdadeiro")
plt.title("Matriz de Confusão")
plt.show()


model.save('minha_imagem_classifica.keras')
print("Model saved to 'minha_imagem_classifica.keras'")

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np

# Caminhos das imagens (diferentes para cada classe)
image_paths = {
    'Paisagem Diurna': '/content/drive/MyDrive/Estudos/imagens/paisagemDia/arvore.jpg',
    'Final da Tarde':'/content/drive/MyDrive/Estudos/imagens/paisagemNoite/finaldatarde.jpg',
}

# Dicionário de nomes de classes (como definido anteriormente)
class_names = {
    0: 'Paisagem Diurna',
    1: 'Final da Tarde',
}

# Carregar e pré-processar as imagens
imgs = []
img_arrays = []
for class_name, img_path in image_paths.items():  # Iterar pelo dicionário
    img = load_img(img_path, target_size=(150, 150))
    imgs.append(img)
    img_array = img_to_array(img) / 255.0
    img_array = img_array.reshape((1, 150, 150, 3))
    img_arrays.append(img_array)

# Fazer as previsões e exibir com nomes de classes distintos
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

for i, (class_name, img_path) in enumerate(image_paths.items()):  # Iterar novamente
    axes[i].imshow(imgs[i])  # Exibir a imagem original

    # Fazer a previsão (opcional, se quiser mostrar a previsão real também)
    prediction = model.predict(img_arrays[i])
    predicted_class_index = int(prediction[0][0] > 0.5)
    predicted_class_name = class_names[predicted_class_index]

    # Definir o título com o nome da classe desejado
    axes[i].set_title(f"Prediction: {class_name}")  # Usar o nome da classe do dicionário
    axes[i].axis('off')

plt.show()

model.save('minha_imagem_DiurnaETarde.keras')

pip install opencv-python pillow

!git clone https://github.com/ultralytics/yolov5

# Commented out IPython magic to ensure Python compatibility.
# %cd yolov5

!pip install -r requirements.txt

import torch

model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

from PIL import Image

img = Image.open('/content/drive/MyDrive/PaisagensDia/imagensDia/arvore.jpg')

img = img.convert('RGB')

# Executar a detecção
results = model(img)

# Exibir os resultados
results.print()  # Imprime informações no console
results.show()  # Mostra a imagem com as detecções
results.save()  # Salva a imagem com as detecções na pasta 'runs/detect/exp'

!git clone https://github.com/ultralytics/yolov5.git

# Commented out IPython magic to ensure Python compatibility.
# %cd yolov5

!pip install -r requirements.txt

import matplotlib.pyplot as plt
import matplotlib.patches as patches
from PIL import Image
import torch

def plot_bounding_box(image_path, label_path, class_names):
    """Plota a imagem com os bounding boxes."""

    # Carrega a imagem
    img = Image.open(image_path)

    # Carrega as anotações do arquivo de rótulos
    with open(label_path, 'r') as f:
        annotations = f.readlines()

    # Cria a figura e os eixos para o plot
    fig, ax = plt.subplots(1)
    ax.imshow(img)

    # Desenha os bounding boxes
    for annotation in annotations:
        # Separa os valores da anotação
        class_id, x_center, y_center, width, height = map(float, annotation.split())

        # Converte as coordenadas normalizadas para pixels
        x_center *= img.width
        y_center *= img.height
        width *= img.width
        height *= img.height

        # Calcula as coordenadas do canto superior esquerdo do bounding box
        x = x_center - width / 2
        y = y_center - height / 2

        # Cria o retângulo do bounding box
       # rect = patches.Rectangle((x, y), width, height, linewidth=2, edgecolor='r', facecolor='none')
        rect = patches.Rectangle((x, y), width, height, linewidth=2, edgecolor='b', facecolor='none')
        # Adiciona o bounding box ao plot
        ax.add_patch(rect)

        # Adiciona o nome da classe ao plot
        class_name = class_names[int(class_id)]
        #ax.text(x, y, class_name, color='w', fontsize=10, backgroundcolor='r')
        ax.text(x, y, class_name, color='w', fontsize=10, backgroundcolor='blue')  # Mude 'blue' para a cor desejada

    # Mostra o plot
    plt.show()

    torch.save(model, 'tarefaCurso.pt')

!python train.py --img 640 --batch 16 --epochs 100 --data data.yaml --weights tarefaCurso.pt

image_path = '/content/drive/MyDrive/dataset/imagens/train/paisagem16.jpeg'
label_path = '/content/drive/MyDrive/dataset/imagens/imagensescrita/paisagem16.txt'

class_names = ['arvore', 'casa','vaca','estrada','nuvem']  # Substitua pelos nomes das suas classes

class_names = {
    0: 'arvore',
    1: 'vaca',
    2: 'piscina',
    3: 'casa',
    4: 'estrada',
    5: 'nuvem'  # Adicione mais classes conforme necessário
}

plot_bounding_box(image_path, label_path, class_names)

import torch
from IPython.display import display, Image  # para exibir imagens no notebook

model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

data_yaml = 'data.yaml'

epochs = 100  # Número de épocas de treinamento
batch_size = 16  # Tamanho do lote
img_size = 640

import yolov5

# ... (código para carregar o modelo) ...

# Define as configurações do dataset como um dicionário
data_dict = {
    'train': '/caminho/para/imagens/de/treinamento',
    'val': '/caminho/para/imagens/de/validação',
    'nc': número_de_classes,  # Substitua pelo número real de classes
    'names': ['nome_classe_1', 'nome_classe_2', ...]  # Substitua pelos nomes das suas classes
}

# Inicia o treinamento, passando o dicionário de configurações
yolov5.train.run(data=data_dict, epochs=epochs, batch_size=batch_size, imgsz=img_size)

!pip install torch torchvision torchaudio --index-url https://download.pytorch.org/index.html
import torch

model = torch.hub.load('ultralytics/yolov5', 'yolov5s')  # Or your custom model path

# Import torch (if not already imported)
import torch

# Assuming 'model' is already loaded using torch.hub.load()

# Save the entire model
torch.save(model, 'minha_imagem_figura.pt')

print("Model saved to 'minha_imagem_figura.pt'")

!pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118

!git clone https://github.com/ultralytics/yolov5

# Commented out IPython magic to ensure Python compatibility.
# %cd yolov5

!pip install -r requirements.txt

!python train.py --img 640 --batch 16 --epochs 3 --train /content/drive/MyDrive/dataset/imagens/train --val /content/drive/MyDrive/dataset/imagens/imagensescrita --nc 5 --names ['arvore', 'casa','vaca','estrada','nuvem'] --cache

pip install opencv-python pillow

import torch

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np
import os

pasta_dataset = '/content/drive/MyDrive/Exemplos'  # Substitua pelo caminho do seu dataset
# Defina os nomes das classes

classes = ['Capinha', 'Garrafa_de_agua', 'PortaDetergente', 'Ursinho_de_pelucia']

from IPython.display import display

# Suponha que o seu dataset seja um DataFrame do Pandas chamado 'df'
display(pasta_dataset)

from tensorflow.keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(
         rescale=1./255,
         shear_range=0.2,
         zoom_range=0.2,
         horizontal_flip=True

     )

test_datagen = ImageDataGenerator(rescale=1./255)


train_generator = train_datagen.flow_from_directory(
         pasta_dataset,
         target_size=(150, 150),  # Ajuste o tamanho conforme necessário
         batch_size=32,
         classes=classes


        # Use 'categorical' para 4 classes
     )
validation_generator = test_datagen.flow_from_directory(
         pasta_dataset,  # Use o mesmo dataset para validação
         target_size=(150, 150),
         batch_size=32,
         classes=classes,
         class_mode='categorical'

     )



import os

nome_dataset = 'Exemplo'
classes = ['capinha', 'Ursopelucia', 'Portadetergente', 'garrafaagua']

os.makedirs(nome_dataset, exist_ok=True)
for classe in classes:
  os.makedirs(os.path.join(nome_dataset, classe), exist_ok=True)

print(f"Dataset '{nome_dataset}' criado com as classes: {classes}")

model = keras.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(4, activation='softmax')  # 4 output neurons for 4 classes
])

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])  # Use 'categorical_crossentropy' for multi-class

history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // train_generator.batch_size,  # Calculate steps per epoch
    epochs=8,  # Adjust the number of epochs as needed
    validation_data=validation_generator,  # Changed from test_generator to validation_generator
    validation_steps=validation_generator.samples // validation_generator.batch_size  # Calculate validation steps
)

classes = ['Capinha', 'Garrafa_de_agua', 'PortaDetergente', 'Ursinho_de_pelucia']

from tensorflow.keras.utils import load_img, img_to_array # Import load_img and img_to_array

img_path = '/content/drive/MyDrive/Exemplos/Ursinho_de_pelucia/ursinhopelucia2.jpg'
img = load_img(img_path, target_size=(150, 150))
img_array = img_to_array(img)
img_array = img_array / 255.0  # Normalização
img_array = np.expand_dims(img_array, axis=0)

prediction = model.predict(img_array)
predicted_class_index = np.argmax(prediction)
predicted_class = classes[predicted_class_index]

print(f"Imagem: {img_path} - Classe Predita: {predicted_class}")

plt.imshow(img)
plt.title(f"Previsão: {predicted_class}")  # Define o título como a classe predita
plt.axis('off')  # Oculta os eixos
plt.show()

model.save('modelofigura.keras')

model.save('recomendacao.keras')  # Adicione aqui
print("Model saved to 'recomendacao.keras'")

import tensorflow as tf
import cv2
import numpy as np

modelo = tf.keras.models.load_model('modelofigura.keras')

imagem_busca = cv2.imread('/content/drive/MyDrive/ursinhoteste.jpg')  # Substitua pelo caminho da sua imagem de busca
imagem_busca = cv2.resize(imagem_busca, (150, 150))  # Redimensionar para o tamanho usado no treinamento
imagem_busca = imagem_busca / 255.0  # Normalizar

caracteristicas_busca = modelo.predict(np.expand_dims(imagem_busca, axis=0))

classes = ['Capinha', 'Garrafa_de_agua', 'PortaDetergente', 'Ursinho_de_pelucia']  # Substitua pelos nomes das suas classes
limite_similaridade = 0.9  # Ajuste este valor conforme necessário

for classe in classes:
    pasta_classe = os.path.join('/content/drive/MyDrive/Exemplos', classe)  # Substitua pelo caminho da sua pasta de imagens
    for nome_arquivo in os.listdir(pasta_classe):
        if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):
            caminho_imagem = os.path.join(pasta_classe, nome_arquivo)
            imagem = cv2.imread(caminho_imagem)
            imagem = cv2.resize(imagem, (150, 150))
            imagem = imagem / 255.0
            caracteristicas_imagem = modelo.predict(np.expand_dims(imagem, axis=0))
            similaridade = np.dot(caracteristicas_busca[0], caracteristicas_imagem[0]) / (np.linalg.norm(caracteristicas_busca[0]) * np.linalg.norm(caracteristicas_imagem[0]))  # Cosseno similarity
            if similaridade >= limite_similaridade:
                print(f'Imagem igual encontrada na classe {classe}: {nome_arquivo}')

import cv2
import matplotlib.pyplot as plt
import os
import numpy as np
import tensorflow as tf

# ... (your existing code for loading the model and other variables) ...


def search_similar_images(search_image_path, model, classes, similarity_threshold=0.8):
    """Searches for similar images and displays them with similarity scores."""

    # Load and preprocess the search image
    search_image = cv2.imread(search_image_path)
    search_image = cv2.resize(search_image, (150, 150))
    search_image = search_image / 255.0
    search_features = model.predict(np.expand_dims(search_image, axis=0))

    # Iterate through classes and images, calculating similarity
    similar_images = []  # List to store similar images and their info
    for classe in classes:
        pasta_classe = os.path.join('/content/drive/MyDrive/Exemplos', classe)
        for nome_arquivo in os.listdir(pasta_classe):
            if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):
                caminho_imagem = os.path.join(pasta_classe, nome_arquivo)
                imagem = cv2.imread(caminho_imagem)
                imagem = cv2.resize(imagem, (150, 150))
                imagem = imagem / 255.0
                caracteristicas_imagem = model.predict(np.expand_dims(imagem, axis=0))
                similaridade = np.dot(search_features[0], caracteristicas_imagem[0]) / (np.linalg.norm(search_features[0]) * np.linalg.norm(caracteristicas_imagem[0]))

                if similaridade > similarity_threshold:
                    similar_images.append({
                        'image': imagem,
                        'path': caminho_imagem,
                        'class': classe,
                        'similarity': similaridade
                    })

    # Display similar images with similarity scores using Matplotlib
    if similar_images:
        num_cols = 3  # Number of columns for displaying images
        num_rows = (len(similar_images) + num_cols - 1) // num_cols  # Number of rows needed

        fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 5 * num_rows))
        axes = axes.flatten()  # Flatten to 1D for easier indexing

        for i, image_info in enumerate(similar_images):
            # Convert the image to uint8 before using cv2.cvtColor
            image_uint8 = (image_info['image'] * 255).astype(np.uint8)  # Convert to uint8
            axes[i].imshow(cv2.cvtColor(image_uint8, cv2.COLOR_BGR2RGB))
            axes[i].set_title(f"Similaridade: {image_info['similarity']:.2f}\nClasse: {image_info['class']}\nCaminho: {image_info['path']}")
            axes[i].axis('off')

        plt.tight_layout()
        plt.show()
    else:
        print("Nenhuma imagem similar encontrada.")

import os
import cv2
import numpy as np
import tensorflow as tf

modelo = tf.keras.models.load_model('modelofigura.keras')

imagem_busca_path = '/content/drive/MyDrive/ursinhoteste.jpg'

imagem_busca = cv2.imread(imagem_busca_path)
imagem_busca = cv2.resize(imagem_busca, (150, 150))
imagem_busca = imagem_busca / 255.0

caracteristicas_busca = modelo.predict(np.expand_dims(imagem_busca, axis=0))

classes = ['Capinha', 'Garrafa_de_agua', 'PortaDetergente', 'Ursinho_de_pelucia']
limite_similaridade = 0.9  # Ajuste conforme necessário

import os
import cv2
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

modelo = tf.keras.models.load_model('modelofigura.keras')

# Caminho da imagem de busca (ursinho de pelúcia)
imagem_busca_path = '/content/drive/MyDrive/ursinhoteste.jpg'

# Carregar e pré-processar a imagem de busca
imagem_busca = cv2.imread(imagem_busca_path)
imagem_busca = cv2.resize(imagem_busca, (150, 150))
imagem_busca = imagem_busca / 255.0

# Extrair características da imagem de busca
caracteristicas_busca = modelo.predict(np.expand_dims(imagem_busca, axis=0))

# *** Determine the class of the search image ***
# Assume class names are in the path (e.g., '/content/drive/MyDrive/Exemplos/Ursinho_de_pelucia/ursinhopelucia2.jpg')

# Fix: Correctly extract the class name from the path
classe_busca = 'Ursinho_de_pelucia'  # Change 'Ursinho_de_pelucia' to the actual class name or folder containing the images you want to search.

limite_similaridade = 0.85  # Ajuste conforme necessário

imagens_similares = []

pasta_classe = '/content/drive/MyDrive/Exemplos'

# *** Search only within the class of the search image ***
pasta_classe = os.path.join(pasta_classe, classe_busca)

for nome_arquivo in os.listdir(pasta_classe):
    if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):
        caminho_imagem = os.path.join(pasta_classe, nome_arquivo)
        imagem = cv2.imread(caminho_imagem)
        imagem = cv2.resize(imagem, (150, 150))
        imagem = imagem / 255.0

        caracteristicas_imagem = modelo.predict(np.expand_dims(imagem, axis=0))

        similaridade = np.dot(caracteristicas_busca[0], caracteristicas_imagem[0]) / (np.linalg.norm(caracteristicas_busca[0]) * np.linalg.norm(caracteristicas_imagem[0]))

        if similaridade >= limite_similaridade and caminho_imagem != imagem_busca_path: # Exclude the search image itself
            imagens_similares.append(caminho_imagem)


# Exibir as imagens similares
if imagens_similares:
    print(f'Imagens similares encontradas na classe: {classe_busca}')

    num_images = len(imagens_similares)
    fig, axes = plt.subplots(1, num_images, figsize=(15, 5))

    for i, img_path in enumerate(imagens_similares):
        img = plt.imread(img_path)
        axes[i].imshow(img)
        axes[i].set_title(f"Imagem Similar: {os.path.basename(img_path)}")
        axes[i].axis('off')

    plt.show()

import os
import cv2
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

modelo = tf.keras.models.load_model('modelofigura.keras')

# Caminho da imagem de busca
imagem_busca_path = '/content/drive/MyDrive/ursinhoteste.jpg'

# Carregar e pré-processar a imagem de busca
imagem_busca = cv2.imread(imagem_busca_path)
imagem_busca = cv2.resize(imagem_busca, (150, 150))
imagem_busca = imagem_busca / 255.0

# Extrair características da imagem de busca
caracteristicas_busca = modelo.predict(np.expand_dims(imagem_busca, axis=0))

limite_similaridade = 0.85  # Ajuste conforme necessário

imagens_similares = []

pasta_principal = '/content/drive/MyDrive/Exemplos'  # Pasta contendo todas as classes


# *** Search in all subfolders (classes) within 'pasta_principal' ***
for classe in os.listdir(pasta_principal):
    pasta_classe = os.path.join(pasta_principal, classe)

    # Check if it's a directory (to avoid files)
    if os.path.isdir(pasta_classe):
        for nome_arquivo in os.listdir(pasta_classe):
            if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):
                caminho_imagem = os.path.join(pasta_classe, nome_arquivo)
                imagem = cv2.imread(caminho_imagem)
                imagem = cv2.resize(imagem, (150, 150))
                imagem = imagem / 255.0

                caracteristicas_imagem = modelo.predict(np.expand_dims(imagem, axis=0))

                similaridade = np.dot(caracteristicas_busca[0], caracteristicas_imagem[0]) / (np.linalg.norm(caracteristicas_busca[0]) * np.linalg.norm(caracteristicas_imagem[0]))

                if similaridade >= limite_similaridade and caminho_imagem != imagem_busca_path:
                    imagens_similares.append((caminho_imagem, similaridade))  # Store similarity score as well


# Exibir as imagens similares, sorted by similarity (descending)
imagens_similares.sort(key=lambda x: x[1], reverse=True)  # Sort by similarity

if imagens_similares:
    print('Imagens similares encontradas:')

    num_images = len(imagens_similares)
    fig, axes = plt.subplots(1, num_images, figsize=(15, 5))

    for i, (img_path, similaridade) in enumerate(imagens_similares):
        img = plt.imread(img_path)
        axes[i].imshow(img)
        axes[i].set_title(f"Similaridade: {similaridade:.2f}")  # Display similarity score
        axes[i].axis('off')

    plt.show()

import os
import cv2
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

modelo = tf.keras.models.load_model('modelofigura.keras')

# Caminho da imagem de busca (ursinho de pelúcia)
imagem_busca_path = '/content/drive/MyDrive/ursinhoteste.jpg'

# Carregar e pré-processar a imagem de busca
imagem_busca = cv2.imread(imagem_busca_path)
imagem_busca = cv2.resize(imagem_busca, (150, 150))
imagem_busca = imagem_busca / 255.0

# Extrair características da imagem de busca
caracteristicas_busca = modelo.predict(np.expand_dims(imagem_busca, axis=0))

# *** Correctly determine the class of the search image ***
# Assuming you want 'Ursinho_de_pelucia' as the class, you should manually set it.
classe_busca = 'Ursinho_de_pelucia' #  or get it from user input

limite_similaridade = 0.85  # Ajuste conforme necessário

imagens_similares = []

# *** Search within the specified class folder ***
pasta_classe = os.path.join('/content/drive/MyDrive/Exemplos/', classe_busca)

for nome_arquivo in os.listdir(pasta_classe):
    if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):
        caminho_imagem = os.path.join(pasta_classe, nome_arquivo)
        imagem = cv2.imread(caminho_imagem)
        imagem = cv2.resize(imagem, (150, 150))
        imagem = imagem / 255.0

        caracteristicas_imagem = modelo.predict(np.expand_dims(imagem, axis=0))

        similaridade = np.dot(caracteristicas_busca[0], caracteristicas_imagem[0]) / (np.linalg.norm(caracteristicas_busca[0]) * np.linalg.norm(caracteristicas_imagem[0]))

        if similaridade >= limite_similaridade and caminho_imagem != imagem_busca_path: # Exclude the search image itself
            imagens_similares.append(caminho_imagem)


# Exibir as imagens similares
if imagens_similares:
    print(f'Imagens similares encontradas na classe: {classe_busca}')

    num_images = len(imagens_similares)
    fig, axes = plt.subplots(1, num_images, figsize=(15, 5))

    for i, img_path in enumerate(imagens_similares):
        img = plt.imread(img_path)
        axes[i].imshow(img)
        axes[i].set_title(f"Imagem Similar: {os.path.basename(img_path)}")
        axes[i].axis('off')

    plt.show()

# Example usage:
search_image_path = '/content/drive/MyDrive/ursinhoteste.jpg'  # Replace with your search image path
classes = ['Capinha', 'Garrafa_de_agua', 'PortaDetergente', 'Ursinho_de_pelucia']  # Replace with your class names
modelo = tf.keras.models.load_model('modelofigura.keras')  # Assuming you have loaded your model
search_similar_images(search_image_path, modelo, classes, similarity_threshold=0.9)



from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.preprocessing.image import ImageDataGenerator

base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(150, 150, 3))

x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(128, activation='relu')(x)
predictions = Dense(5, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=predictions)

for layer in base_model.layers:
    layer.trainable = False

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True
)

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.fit(train_datagen.flow_from_directory(
    '/content/drive/MyDrive/Exemplos',  # Substitua pelo seu diretório
    target_size=(150, 150),
    batch_size=32,
    class_mode='categorical'
), epochs=10)  # Ajuste o número de épocas

model.save('recomendacao.keras')  # Adicione aqui
print("Model saved to 'recomendacao.keras'")

from IPython.display import Image
import tensorflow as tf

import cv2

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

img = cv2.imread('/content/drive/MyDrive/Tarefaface/Tarefaface.jpg')

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

faces = face_cascade.detectMultiScale(gray, 1.1, 4)

from google.colab.patches import cv2_imshow # Import the cv2_imshow function
import cv2

for (x, y, w, h) in faces:
       cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)



import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
img = cv2.imread('/content/drive/MyDrive/Tarefaface/Tarefaface.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

faces = face_cascade.detectMultiScale(gray, 1.1, 4)

for (x, y, w, h) in faces:
    cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the image using matplotlib.pyplot
# Convert BGR to RGB before displaying with matplotlib
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_rgb)
plt.title('Face Detection')
plt.axis('off')  # Hide axis ticks and labels
plt.show()

from IPython import get_ipython
from IPython.display import display
import imageio
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import os
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator

import imageio
import numpy as np

def convert_to_grayscale_imageio(image_path):
  """Converte uma imagem para escala de cinza usando imageio.

  Args:
    image_path: O caminho para o arquivo de imagem.

  Returns:
    Uma imagem em escala de cinza como um array NumPy.
  """
  # Lê a imagem usando imageio
  img = imageio.imread(image_path)

  # Verifica se a imagem é colorida (tem 3 canais)
  if img.ndim == 3 and img.shape[2] == 3:
    # Calcula a média ponderada dos canais RGB para obter a escala de cinza
    grayscale_img = np.dot(img[..., :3], [0.299, 0.587, 0.114]).astype(np.uint8)
  else:
    # Se a imagem já estiver em escala de cinza ou tiver um formato diferente, retorna a imagem original
    grayscale_img = img

  return grayscale_img

# Exemplo de uso:
image_path = '/content/drive/MyDrive/Tarefaface.jpg'  # Substitua pelo caminho da sua imagem
grayscale_image = convert_to_grayscale_imageio(image_path)

# Para exibir a imagem em escala de cinza:
import matplotlib.pyplot as plt
plt.imshow(grayscale_image, cmap='gray')
plt.show()

face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

img = cv2.imread('/content/drive/MyDrive/Tarefaface/Tarefaface.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

faces = face_cascade.detectMultiScale(gray, 1.1, 4)

for (x, y, w, h) in faces:
       cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_rgb)
plt.title('Face Detection')
plt.axis('off')
plt.show()

import pandas as pd
import cv2
import matplotlib.pyplot as plt

# 1. Load the data from the CSV file
data = pd.read_csv('/content/drive/MyDrive/exemplotarefa.csv')

# 2. Create a Haar Cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# 3. Iterate through the rows of the DataFrame and detect/display faces
for index, row in data.iterrows():
    # a. Read the image
    # Replace 'Tarefaface.jpg' with the actual column name containing the image paths
    img_path = row['Tarefaface.jpg']  # Replace 'Tarefaface.jpg' with the correct column name
    img = cv2.imread(img_path)

    # b. Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # c. Detect faces
    faces = face_cascade.detectMultiScale(gray, 1.1, 4)

    # d. Draw rectangles around the detected faces
    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # e. Display the image with the detected faces
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title('Rostos Detectados')
    plt.axis('off')
    plt.show()

import pandas as pd
import cv2
import matplotlib.pyplot as plt
import os

# 1. Load the data from the CSV file
data = pd.read_csv('/content/drive/MyDrive/exemplotarefa.csv')

# 2. Get the list of image files from the folder
folder_path = '/content/drive/MyDrive/Tarefaface'  # Replace with your folder path
image_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

# 3. Create a Haar Cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# 4. Iterate through the image files and detect/display faces
for image_file in image_files:
    # a. Construct the image path
    img_path = os.path.join(folder_path, image_file)

    # b. Read the image
    img = cv2.imread(img_path)

    # c. Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # d. Detect faces
    faces = face_cascade.detectMultiScale(gray, 1.1, 4)

    # e. Draw rectangles around the detected faces
    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # f. Display the image with the detected faces
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title('Rostos Detectados')
    plt.axis('off')
    plt.show()

import pandas as pd
import cv2
import matplotlib.pyplot as plt
import os

# 1. Load the data from the CSV file
data = pd.read_csv('/content/drive/MyDrive/exemplotarefa.csv')

# 2. Get the list of image files from the folder
folder_path = '/content/drive/MyDrive/Tarefaface'  # Replace with your folder path
image_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

# 3. Create a Haar Cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# 4. Iterate through the image files and detect/display faces
for image_file in image_files:
    # a. Construct the image path
    img_path = os.path.join(folder_path, image_file)

    # b. Read the image
    img = cv2.imread(img_path)

    # Check if image loading was successful
    if img is None:
        print(f"Error: Could not load image at {img_path}")
        continue  # Skip to the next image

    # c. Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # d. Detect faces
    faces = face_cascade.detectMultiScale(gray, 1.1, 4)

    # e. Draw rectangles around the detected faces
    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # f. Display the image with the detected faces
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title('Rostos Detectados')
    plt.axis('off')
    plt.show()

import pandas as pd
import cv2
import matplotlib.pyplot as plt
import os

# 1. Load the data from the CSV file
data = pd.read_csv('/content/drive/MyDrive/exemplotarefa.csv')

# 2. Get the list of image files from the folder
folder_path = '/content/drive/MyDrive/Tarefaface'  # Replace with your folder path
image_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

# 3. Create a Haar Cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# 1. Load the data from the CSV file
data = pd.read_csv('/content/drive/MyDrive/exemplotarefa.csv')

# 2. Get the list of image files from the folder
folder_path = '/content/drive/MyDrive/Tarefaface'  # Replace with your folder path
image_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

# 3. Create a Haar Cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

import cv2
import matplotlib.pyplot as plt

# Load the image for recognition
img = cv2.imread('/content/drive/MyDrive/Tarefaface/Tarefaface.jpg')  # Replace with your image path

# Detect faces and extract features (similar to Example 1)
# ...

# Make prediction using the trained SVM classifier
# ... (prediction = svm_classifier.predict(features))

# Overlay label on the image
for (x, y, w, h) in faces:
    cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)  # Draw rectangle
    cv2.putText(img, prediction, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)  # Add label

# Display the image with label
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert for matplotlib
plt.imshow(img_rgb)
plt.title('Face Recognition')
plt.axis('off')
plt.show()

import torch
import cv2
from google.colab.patches import cv2_imshow

model = torch.hub.load('ultralytics/yolov5', 'yolov5s')  # or any other YOLOv5 variant

img = cv2.imread('/content/drive/MyDrive/testefoto.jpg')  # Replace with your image path
results = model(img)

# Results will contain bounding boxes and confidence scores for detected faces.
# Access them using results.pandas().xyxy[0]

# Draw bounding boxes on the image
for *xyxy, conf, cls in results.xyxy[0]:
    x1, y1, x2, y2 = map(int, xyxy)
    cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)

cv2_imshow(img)  # Display the image with bounding boxes

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5

!pip install -r requirements.txt

from google.colab import drive
drive.mount('/content/drive')

!python train.py --img 640 --batch 16 --epochs 100 --data /content/drive/MyDrive/tareface/data.yaml --weights yolov5s.pt  # Substitua pelo caminho real